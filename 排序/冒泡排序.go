package main

import "fmt"

var arrays = []int{4, 2, 7, 1, 3, 9, 5, 6, 11, 23, 65, 56, 98, 87, 67, 40}

func main() {
	n := len(arrays)
	if n < 1 {
		return
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n-1; j++ {
			if arrays[j] > arrays[j+1] {
				arrays[j], arrays[j+1] = arrays[j+1], arrays[j]
			}
		}

	}
	fmt.Println(arrays)

}

/*
冒泡排序只会操作相邻的两个数据。
每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
如果不满足就让他俩互换。
一次冒泡会让至少一个元素移动到它应该在位置，重复N次，就完成了n个数据的排序工作。
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
在冒泡排序中，只有交换才可以改变两个元素的前后顺序。
为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换。
相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
时间复杂度：
	最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了,所以最好情况时间复杂度是 O(n)。
	而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。
https://visualgo.net/zh/sorting
*/
